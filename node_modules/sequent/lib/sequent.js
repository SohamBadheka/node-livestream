// Generated by CoffeeScript 1.6.2
(function() {
  var DEBUG, Sequent, doImmediately, idCounter,
    __slice = [].slice;

  DEBUG = false;

  doImmediately = typeof setImmediate !== "undefined" && setImmediate !== null ? setImmediate : function(callback) {
    return setTimeout(callback, 0);
  };

  idCounter = 1;

  Sequent = (function() {
    Sequent.prototype.toString = function() {
      var str;

      str = "[seq:" + this.id + "]";
      if (this.waits != null) {
        str += " " + this.finished + "/" + this.waits;
      }
      if (this.isCallbackExecuted) {
        str += " (finished)";
      }
      return str;
    };

    function Sequent(params) {
      var _ref;

      this.id = idCounter++;
      this.waits = null;
      this.finished = 0;
      this.args = [];
      this.matured = false;
      this.loops = 0;
      this.loopCallbacks = [];
      this.executedLoops = 0;
      this.readyLoops = [];
      this.readyLoopArgs = [];
      this.isCallbackExecuted = false;
      this.quiet = (_ref = params != null ? params.quiet : void 0) != null ? _ref : false;
    }

    Sequent.prototype.rewind = function() {
      this.finished = 0;
      return this.matured = false;
    };

    Sequent.prototype.reset = function() {
      this.waits = null;
      this.finished = 0;
      this.callback = null;
      this.args = [];
      this.matured = false;
      this.loops = 0;
      this.loopCallbacks = [];
      this.executedLoops = 0;
      this.readyLoops = [];
      this.readyLoopArgs = [];
      return this.isCallbackExecuted = false;
    };

    Sequent.prototype.wait = function(waits, callback) {
      var finished;

      this.waits = waits;
      this.callback = callback;
      finished = this.finished;
      if (DEBUG) {
        console.log("wait: waits=" + waits + " finished=" + finished);
      }
      if (waits != null) {
        if (this.matured) {
          if (!this.isCallbackExecuted) {
            if (DEBUG) {
              console.log("execute matured callback on wait(): " + callback);
            }
            this.isCallbackExecuted = true;
            return typeof callback === "function" ? callback.apply(null, this.args) : void 0;
          } else {
            if (DEBUG) {
              return console.log("wait and matured but callback has already been executed");
            }
          }
        } else {
          if (finished === waits) {
            if (!this.isCallbackExecuted) {
              if (DEBUG) {
                console.log("execute callback from wait()");
              }
              this.isCallbackExecuted = true;
              return typeof callback === "function" ? callback.apply(null, this.args) : void 0;
            } else {
              if (DEBUG) {
                return console.log("wait ready but callback has already been executed");
              }
            }
          } else if (finished > waits) {
            if (!this.quiet) {
              return console.log("[WARN] extra done() has been called: done=" + finished + " > wait=" + waits);
            }
          }
        }
      } else {
        throw new Error("You have to specify the number of waits");
      }
    };

    Sequent.prototype.mature = function() {
      var args;

      if (this.matured) {
        console.log("[info] matured multiple times, ignored");
        return;
      }
      this.matured = true;
      if (DEBUG) {
        console.log("[info] mature");
      }
      args = this.args = __slice.call(arguments);
      if (this.waits != null) {
        if (DEBUG) {
          console.log("execute matured callback on mature()");
        }
        this.isCallbackExecuted = true;
        return typeof this.callback === "function" ? this.callback.apply(this, args) : void 0;
      } else {
        if (DEBUG) {
          return console.log("matured but callback hasn't ready");
        }
      }
    };

    Sequent.prototype.done = function() {
      var args, finished, waits;

      waits = this.waits;
      finished = ++this.finished;
      if (DEBUG) {
        console.log("done waits=" + waits + " finished=" + finished);
      }
      args = this.args = __slice.call(arguments);
      if (waits != null) {
        if (finished === waits) {
          if (!this.isCallbackExecuted) {
            if (DEBUG) {
              console.log("execute callback from done()");
            }
            this.isCallbackExecuted = true;
            return this.callback.apply(this, args);
          } else {
            if (DEBUG) {
              return console.log("done but callback has already been executed");
            }
          }
        } else if (finished > waits) {
          if (!this.quiet) {
            return console.log("[WARN] extra done() has been called: done=" + finished + " > wait=" + waits);
          }
        }
      } else {
        if (DEBUG) {
          return console.log("done but callback hasn't ready");
        }
      }
    };

    Sequent.prototype.join = Sequent.wait;

    Sequent.prototype.queue = function(callback) {
      var loops,
        _this = this;

      loops = this.loops++;
      if (DEBUG) {
        console.log("queueing callback " + loops);
      }
      return this.loopCallbacks[loops] = function() {
        if (_this.executedLoops === loops) {
          _this.i = loops;
          _this.executedLoops++;
          if (DEBUG) {
            console.log("[" + loops + "] executing loop");
          }
          callback.apply(null, arguments);
          if (_this.readyLoops[loops + 1]) {
            if (DEBUG) {
              console.log("[" + loops + "] executing chaining next callback");
            }
            return doImmediately(function() {
              var _ref;

              return (_ref = _this.loopCallbacks)[loops + 1].apply(_ref, _this.readyLoopArgs[loops + 1]);
            });
          } else {
            if (DEBUG) {
              console.log("[" + loops + "] waiting for next callback to be executed");
            }
            if (_this.executedLoops === _this.loops) {
              if (DEBUG) {
                console.log("flush callback in queue()");
              }
              return typeof _this.flushCallback === "function" ? _this.flushCallback() : void 0;
            }
          }
        } else {
          if (DEBUG) {
            console.log("[" + loops + "] waiting for previous callback to be executed");
          }
          _this.readyLoops[loops] = true;
          return _this.readyLoopArgs[loops] = __slice.call(arguments);
        }
      };
    };

    Sequent.prototype.flush = function(callback) {
      if (this.executedLoops === this.loops) {
        if (DEBUG) {
          console.log("flush callback in flush()");
        }
        return typeof callback === "function" ? callback() : void 0;
      } else {
        return this.flushCallback = callback;
      }
    };

    return Sequent;

  })();

  if ((typeof define !== "undefined" && define !== null) && define.amd) {
    define(function() {
      return Sequent;
    });
  } else if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
    module.exports = Sequent;
  } else {
    this.Sequent = Sequent;
  }

}).call(this);
